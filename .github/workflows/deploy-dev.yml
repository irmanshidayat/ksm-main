# =============================================================================
# GitHub Actions - Deployment Development
# =============================================================================
# 
# Workflow untuk deployment otomatis ke development server
# Trigger: Push ke branch 'dev'
# 
# Requirements:
# - GitHub Secrets:
#   - SSH_HOST_DEV: IP/hostname server development
#   - SSH_USER_DEV: Username SSH untuk development
#   - SSH_KEY_DEV: Private SSH key untuk development
#   - DEPLOY_PATH_DEV: Path di server (default: /opt/ksm-main-dev)
# 
# Note: VPS menggunakan port SSH 22 (port default)
# =============================================================================

name: Deploy Development

on:
  push:
    branches:
      - dev
  workflow_dispatch: # Manual trigger

env:
  COMPOSE_FILE: docker-compose.dev.yml
  DEPLOY_ENV: development

jobs:
  deploy:
    name: Deploy to Development Server
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate required secrets
        run: |
          echo "üîç Validating required secrets..."
          MISSING_SECRETS=()
          
          if [ -z "${{ secrets.SSH_HOST_DEV }}" ]; then
            MISSING_SECRETS+=("SSH_HOST_DEV")
          fi
          
          if [ -z "${{ secrets.SSH_USER_DEV }}" ]; then
            MISSING_SECRETS+=("SSH_USER_DEV")
          fi
          
          if [ -z "${{ secrets.SSH_KEY_DEV }}" ]; then
            MISSING_SECRETS+=("SSH_KEY_DEV")
          fi
          
          if [ ${#MISSING_SECRETS[@]} -gt 0 ]; then
            echo ""
            echo "‚ùå ERROR: Required secrets are not set!"
            echo ""
            echo "Missing secrets:"
            for secret in "${MISSING_SECRETS[@]}"; do
              echo "  - $secret"
            done
            echo ""
            echo "üìù To fix this, please add the following secrets in GitHub:"
            echo "   1. Go to: Repository ‚Üí Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo "   2. Click 'New repository secret'"
            echo "   3. Add each secret:"
            echo ""
            echo "   Required secrets for Development:"
            echo "   - SSH_HOST_DEV: IP atau hostname server (contoh: 72.61.142.109)"
            echo "   - SSH_USER_DEV: Username SSH (contoh: root)"
            echo "   - SSH_KEY_DEV: Private SSH key (full key dengan header/footer)"
            echo "   - DEPLOY_PATH_DEV: (Optional) Path deployment (default: /opt/ksm-main-dev)"
            echo ""
            echo "   Example SSH_KEY_DEV format:"
            echo "   -----BEGIN OPENSSH PRIVATE KEY-----"
            echo "   ..."
            echo "   -----END OPENSSH PRIVATE KEY-----"
            echo ""
            exit 1
          fi
          
          echo "‚úÖ All required secrets are set!"

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_KEY_DEV }}

      - name: Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          ssh-keyscan -H -p 22 ${{ secrets.SSH_HOST_DEV }} >> ~/.ssh/known_hosts 2>&1 || {
            echo "‚ö†Ô∏è  Warning: ssh-keyscan failed, but continuing..."
            echo "This might be due to network issues or server unreachable."
          }
          chmod 600 ~/.ssh/known_hosts

      - name: Test SSH connection
        run: |
          echo "üîê Testing SSH connection..."
          ssh -p 22 -o ConnectTimeout=10 -o StrictHostKeyChecking=no -o BatchMode=yes \
            ${{ secrets.SSH_USER_DEV }}@${{ secrets.SSH_HOST_DEV }} \
            "echo 'SSH connection successful'" || {
            echo ""
            echo "‚ùå ERROR: SSH connection failed!"
            echo ""
            echo "Possible causes:"
            echo "  1. SSH public key belum ditambahkan ke server's authorized_keys"
            echo "  2. Format SSH private key di GitHub Secrets salah"
            echo "  3. SSH key tidak match dengan public key di server"
            echo "  4. Server SSH configuration tidak mengizinkan key authentication"
            echo ""
            echo "üìù To fix this:"
            echo ""
            echo "Step 1: Generate SSH key (jika belum ada):"
            echo "  ssh-keygen -t ed25519 -C 'github-actions-deploy' -f ~/.ssh/github_actions_deploy"
            echo ""
            echo "Step 2: Copy public key ke server:"
            echo "  ssh-copy-id -i ~/.ssh/github_actions_deploy.pub -p 22 ${{ secrets.SSH_USER_DEV }}@${{ secrets.SSH_HOST_DEV }}"
            echo ""
            echo "  Atau manual:"
            echo "  cat ~/.ssh/github_actions_deploy.pub | ssh -p 22 ${{ secrets.SSH_USER_DEV }}@${{ secrets.SSH_HOST_DEV }} \\"
            echo "    'mkdir -p ~/.ssh && chmod 700 ~/.ssh && cat >> ~/.ssh/authorized_keys && chmod 600 ~/.ssh/authorized_keys'"
            echo ""
            echo "Step 3: Test connection manually:"
            echo "  ssh -p 22 -i ~/.ssh/github_actions_deploy ${{ secrets.SSH_USER_DEV }}@${{ secrets.SSH_HOST_DEV }}"
            echo ""
            echo "Step 4: Copy private key ke GitHub Secrets (SSH_KEY_DEV):"
            echo "  cat ~/.ssh/github_actions_deploy"
            echo ""
            echo "  Pastikan format lengkap dengan header dan footer:"
            echo "  -----BEGIN OPENSSH PRIVATE KEY-----"
            echo "  ..."
            echo "  -----END OPENSSH PRIVATE KEY-----"
            echo ""
            echo "Step 5: Verify server SSH config (di server):"
            echo "  sudo nano /etc/ssh/sshd_config"
            echo "  Pastikan:"
            echo "    - PubkeyAuthentication yes"
            echo "    - AuthorizedKeysFile .ssh/authorized_keys"
            echo "  Lalu restart: sudo systemctl restart sshd"
            echo ""
            exit 1
          }
          echo "‚úÖ SSH connection successful!"

      - name: Create deployment directory
        env:
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH_DEV || '/opt/ksm-main-dev' }}
        run: |
          ssh -p 22 ${{ secrets.SSH_USER_DEV }}@${{ secrets.SSH_HOST_DEV }} \
            "mkdir -p $DEPLOY_PATH"

      - name: Copy docker-compose file
        env:
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH_DEV || '/opt/ksm-main-dev' }}
        run: |
          scp -P 22 ksm-main/docker-compose.dev.yml \
            ${{ secrets.SSH_USER_DEV }}@${{ secrets.SSH_HOST_DEV }}:$DEPLOY_PATH/docker-compose.yml

      - name: Copy infrastructure files
        env:
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH_DEV || '/opt/ksm-main-dev' }}
        run: |
          ssh -p 22 ${{ secrets.SSH_USER_DEV }}@${{ secrets.SSH_HOST_DEV }} \
            "mkdir -p $DEPLOY_PATH/infrastructure"
          
          scp -P 22 -r ksm-main/infrastructure/* \
            ${{ secrets.SSH_USER_DEV }}@${{ secrets.SSH_HOST_DEV }}:$DEPLOY_PATH/infrastructure/

      - name: Copy backend files
        env:
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH_DEV || '/opt/ksm-main-dev' }}
        run: |
          ssh -p 22 ${{ secrets.SSH_USER_DEV }}@${{ secrets.SSH_HOST_DEV }} \
            "mkdir -p $DEPLOY_PATH/backend"
          
          rsync -avz -e "ssh -p 22" --exclude='__pycache__' --exclude='*.pyc' --exclude='.venv' --exclude='ksm_venv' \
            ksm-main/backend/ \
            ${{ secrets.SSH_USER_DEV }}@${{ secrets.SSH_HOST_DEV }}:$DEPLOY_PATH/backend/

      - name: Copy frontend-vite files
        env:
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH_DEV || '/opt/ksm-main-dev' }}
        run: |
          ssh -p 22 ${{ secrets.SSH_USER_DEV }}@${{ secrets.SSH_HOST_DEV }} \
            "mkdir -p $DEPLOY_PATH/frontend-vite"
          
          rsync -avz -e "ssh -p 22" --exclude='node_modules' --exclude='dist' --exclude='.next' \
            ksm-main/frontend-vite/ \
            ${{ secrets.SSH_USER_DEV }}@${{ secrets.SSH_HOST_DEV }}:$DEPLOY_PATH/frontend-vite/

      - name: Copy Agent AI files
        env:
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH_DEV || '/opt/ksm-main-dev' }}
        run: |
          ssh -p 22 ${{ secrets.SSH_USER_DEV }}@${{ secrets.SSH_HOST_DEV }} \
            "mkdir -p $DEPLOY_PATH/../Agent AI"
          
          rsync -avz -e "ssh -p 22" --exclude='__pycache__' --exclude='*.pyc' --exclude='.venv' --exclude='agent_venv' \
            "Agent AI/" \
            ${{ secrets.SSH_USER_DEV }}@${{ secrets.SSH_HOST_DEV }}:$DEPLOY_PATH/../Agent\ AI/

      - name: Create logs directory
        env:
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH_DEV || '/opt/ksm-main-dev' }}
        run: |
          ssh -p 22 ${{ secrets.SSH_USER_DEV }}@${{ secrets.SSH_HOST_DEV }} \
            "mkdir -p $DEPLOY_PATH/logs/{mysql-dev,nginx-dev,redis-dev}"

      - name: Deploy with Docker Compose
        env:
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH_DEV || '/opt/ksm-main-dev' }}
        run: |
          ssh -p 22 ${{ secrets.SSH_USER_DEV }}@${{ secrets.SSH_HOST_DEV }} << EOF
            set -e
            cd $DEPLOY_PATH
            
            # Function to check if port is in use by Docker
            check_docker_port() {
              local PORT=\$1
              # Check if any Docker container is using this port
              docker ps --format "{{.ID}} {{.Ports}}" | grep -q ":\$PORT->" && return 0 || return 1
            }
            
            # Function to kill process using a port
            kill_port() {
              local PORT=\$1
              local FORCE=\${2:-false}
              echo "üîç Checking port \$PORT..."
              
              # First check if Docker container is using the port
              if check_docker_port \$PORT; then
                echo "‚ö†Ô∏è  Port \$PORT is in use by Docker container..."
                CONTAINER_ID=\$(docker ps --format "{{.ID}} {{.Ports}}" | grep ":\$PORT->" | awk '{print \$1}' | head -1)
                if [ -n "\$CONTAINER_ID" ]; then
                  echo "üóëÔ∏è  Removing container \$CONTAINER_ID..."
                  docker rm -f \$CONTAINER_ID 2>/dev/null || true
                  sleep 3
                fi
              fi
              
              # Find process using the port (try multiple methods)
              local PID=""
              
              # Method 1: lsof (if available)
              if command -v lsof >/dev/null 2>&1; then
                PID=\$(lsof -ti:\$PORT 2>/dev/null || echo "")
              fi
              
              # Method 2: ss + fuser (if lsof not available)
              if [ -z "\$PID" ] && command -v ss >/dev/null 2>&1; then
                PID=\$(ss -tlnp | grep ":\$PORT " | awk '{print \$7}' | cut -d',' -f2 | cut -d'=' -f2 | head -1 | grep -oE '[0-9]+' || echo "")
              fi
              
              # Method 3: netstat (fallback)
              if [ -z "\$PID" ] && command -v netstat >/dev/null 2>&1; then
                PID=\$(netstat -tlnp 2>/dev/null | grep ":\$PORT " | awk '{print \$7}' | cut -d'/' -f1 | head -1 || echo "")
              fi
              
              # Method 4: fuser (direct)
              if [ -z "\$PID" ] && command -v fuser >/dev/null 2>&1; then
                PID=\$(fuser \$PORT/tcp 2>/dev/null | awk '{print \$1}' || echo "")
              fi
              
              if [ -n "\$PID" ] && [ "\$PID" != "-" ] && [ "\$PID" != "cannot" ]; then
                echo "‚ö†Ô∏è  Port \$PORT is in use by PID \$PID. Killing process..."
                kill -9 \$PID 2>/dev/null || true
                sleep 2
                
                # Verify port is freed
                if lsof -ti:\$PORT >/dev/null 2>&1 || (command -v ss >/dev/null 2>&1 && ss -tlnp | grep -q ":\$PORT "); then
                  echo "‚ö†Ô∏è  Port \$PORT still in use, trying harder..."
                  pkill -9 -f ":\$PORT" || true
                  sleep 2
                fi
                echo "‚úÖ Port \$PORT freed"
              else
                # Double check with Docker
                if check_docker_port \$PORT; then
                  echo "‚ö†Ô∏è  Port \$PORT still in use by Docker, removing container..."
                  CONTAINER_ID=\$(docker ps --format "{{.ID}} {{.Ports}}" | grep ":\$PORT->" | awk '{print \$1}' | head -1)
                  if [ -n "\$CONTAINER_ID" ]; then
                    docker rm -f \$CONTAINER_ID 2>/dev/null || true
                    sleep 2
                  fi
                else
                  echo "‚úÖ Port \$PORT is free"
                fi
              fi
            }
            
            # Function to cleanup Docker resources
            cleanup_docker() {
              echo "üßπ Cleaning up Docker resources..."
              
              # Stop and remove all containers
              echo "üõë Stopping existing containers..."
              docker-compose -f docker-compose.yml down --remove-orphans || true
              
              # Wait for containers to fully stop
              sleep 5
              
              # Remove any dangling containers with KSM prefix
              echo "üóëÔ∏è  Removing dangling containers..."
              docker ps -a --filter "name=KSM-" --format "{{.ID}}" | xargs -r docker rm -f 2>/dev/null || true
              
              # Force remove any containers using required ports
              for PORT in 8002 3310 6381 6333 6334 5002 3006 8084 8444 9092 3007 8085; do
                CONTAINER_ID=\$(docker ps --format "{{.ID}} {{.Ports}}" | grep ":\$PORT->" | awk '{print \$1}' | head -1)
                if [ -n "\$CONTAINER_ID" ]; then
                  echo "‚ö†Ô∏è  Found container \$CONTAINER_ID using port \$PORT, removing..."
                  docker rm -f \$CONTAINER_ID 2>/dev/null || true
                fi
              done
              
              # Remove any dangling networks
              echo "üóëÔ∏è  Removing dangling networks..."
              docker network ls --filter "name=KSM-dev" --format "{{.ID}}" | xargs -r docker network rm 2>/dev/null || true
              
              # Prune unused networks
              echo "üßπ Pruning unused networks..."
              docker network prune -f || true
              
              # Cleanup iptables rules that might be holding ports
              # Note: This requires root/sudo, so we'll try but not fail if it doesn't work
              echo "üßπ Cleaning up iptables rules (if accessible)..."
              if command -v iptables >/dev/null 2>&1 && [ "\$(id -u)" = "0" ]; then
                # Remove Docker iptables rules for our ports (requires root)
                for PORT in 8002 3310 6381 6333 6334 5002 3006 8084 8444 9092 3007 8085; do
                  # Try to find and remove NAT rules
                  iptables -t nat -S DOCKER 2>/dev/null | grep "dport \$PORT" | sed 's/-A/-D/' | xargs -r iptables -t nat 2>/dev/null || true
                  # Try to find and remove filter rules
                  iptables -t filter -S DOCKER 2>/dev/null | grep "dport \$PORT" | sed 's/-A/-D/' | xargs -r iptables -t filter 2>/dev/null || true
                done
              else
                echo "‚ö†Ô∏è  Skipping iptables cleanup (requires root privileges)"
              fi
              
              # Wait for Docker daemon to release ports
              echo "‚è≥ Waiting for Docker daemon to release ports..."
              sleep 10
              
              echo "‚úÖ Docker cleanup completed"
            }
            
            # Cleanup Docker resources first
            cleanup_docker
            
            # Check and free required ports
            echo "üîç Checking required ports..."
            kill_port 8002  # Backend
            kill_port 3310  # MySQL
            kill_port 6381  # Redis
            kill_port 6333  # Qdrant REST
            kill_port 6334  # Qdrant gRPC
            kill_port 5002  # Agent AI
            kill_port 3006  # Frontend
            kill_port 8084  # Nginx HTTP
            kill_port 8444  # Nginx HTTPS
            kill_port 9092  # Prometheus
            kill_port 3007  # Grafana
            kill_port 8085  # Adminer
            
            # Wait a bit for ports to be fully released
            echo "‚è≥ Waiting for ports to be fully released..."
            sleep 10
            
            # Verify ports are free
            echo "üîç Verifying ports are free..."
            for PORT in 8002 3310 6381 6333 6334 5002 3006 8084 8444 9092 3007 8085; do
              # Check Docker containers first
              if check_docker_port \$PORT; then
                echo "‚ö†Ô∏è  Warning: Port \$PORT is still in use by Docker container, attempting to free..."
                CONTAINER_ID=\$(docker ps --format "{{.ID}} {{.Ports}}" | grep ":\$PORT->" | awk '{print \$1}' | head -1)
                if [ -n "\$CONTAINER_ID" ]; then
                  echo "üóëÔ∏è  Force removing container \$CONTAINER_ID..."
                  docker rm -f \$CONTAINER_ID 2>/dev/null || true
                  sleep 3
                fi
              fi
              
              # Check system processes
              if lsof -ti:\$PORT >/dev/null 2>&1 || (command -v ss >/dev/null 2>&1 && ss -tlnp | grep -q ":\$PORT "); then
                echo "‚ö†Ô∏è  Warning: Port \$PORT is still in use by system process, attempting to free..."
                kill_port \$PORT true
                sleep 3
              fi
            done
            
            # Final wait for Docker daemon
            echo "‚è≥ Final wait for Docker daemon to release all ports..."
            sleep 10
            
            # Check if .env file exists
            if [ ! -f .env ]; then
              echo "‚ö†Ô∏è  Warning: .env file not found. Creating from example..."
              if [ -f env.dev.example ]; then
                cp env.dev.example .env
                echo "‚úÖ Created .env from env.dev.example"
              else
                echo "‚ö†Ô∏è  env.dev.example not found. Services may fail without proper configuration."
              fi
            fi
            
            # Build and start services
            echo "üî® Building Docker images..."
            
            # Solusi 1: Build dengan cache (lebih cepat) - uncomment untuk menggunakan
            # docker-compose -f docker-compose.yml build || {
            #   echo "‚ùå Build failed! Showing logs..."
            #   docker-compose -f docker-compose.yml logs --tail=50
            #   exit 1
            # }
            
            # Solusi 2: Build dengan retry dan timeout yang lebih baik
            MAX_BUILD_RETRIES=3
            BUILD_RETRY=0
            BUILD_SUCCESS=false
            
            while [ \$BUILD_RETRY -lt \$MAX_BUILD_RETRIES ] && [ "\$BUILD_SUCCESS" = "false" ]; do
              BUILD_RETRY=\$((BUILD_RETRY + 1))
              echo "üîÑ Build attempt \$BUILD_RETRY/\$MAX_BUILD_RETRIES..."
              
              # Build dengan timeout per service untuk menghindari hang
              if DOCKER_BUILDKIT=1 COMPOSE_DOCKER_CLI_BUILD=1 \
                 timeout 1800 docker-compose -f docker-compose.yml build --parallel --progress=plain 2>&1 | tee /tmp/build.log; then
                BUILD_SUCCESS=true
                echo "‚úÖ Build successful!"
              else
                BUILD_EXIT_CODE=\${PIPESTATUS[0]}
                if [ \$BUILD_EXIT_CODE -eq 124 ]; then
                  echo "‚è±Ô∏è  Build timeout (30 minutes). Retrying..."
                else
                  echo "‚ùå Build failed with exit code \$BUILD_EXIT_CODE"
                  echo "üìã Last 50 lines of build log:"
                  tail -50 /tmp/build.log || true
                  
                  if [ \$BUILD_RETRY -lt \$MAX_BUILD_RETRIES ]; then
                    echo "üîÑ Retrying in 10 seconds..."
                    sleep 10
                  else
                    echo "‚ùå All build attempts failed!"
                    docker-compose -f docker-compose.yml logs --tail=50 || true
                    exit 1
                  fi
                fi
              fi
            done
            
            if [ "\$BUILD_SUCCESS" = "false" ]; then
              echo "‚ùå Build failed after \$MAX_BUILD_RETRIES attempts!"
              exit 1
            fi
            
            # Start services with retry logic
            echo "üöÄ Starting services..."
            
            # Final check before starting - ensure no containers are using our ports
            echo "üîç Final pre-start port check..."
            for PORT in 8002 3310 6381 6333 6334 5002 3006 8084 8444 9092 3007 8085; do
              if check_docker_port \$PORT; then
                echo "‚ö†Ô∏è  Port \$PORT is still in use by Docker container before start, removing..."
                CONTAINER_ID=\$(docker ps --format "{{.ID}} {{.Ports}}" | grep ":\$PORT->" | awk '{print \$1}' | head -1)
                if [ -n "\$CONTAINER_ID" ]; then
                  echo "üóëÔ∏è  Force removing container \$CONTAINER_ID..."
                  docker rm -f \$CONTAINER_ID 2>/dev/null || true
                  sleep 2
                fi
              fi
            done
            sleep 5
            
            MAX_START_RETRIES=3
            START_RETRY=0
            START_SUCCESS=false
            
            while [ \$START_RETRY -lt \$MAX_START_RETRIES ] && [ "\$START_SUCCESS" = "false" ]; do
              START_RETRY=\$((START_RETRY + 1))
              echo "üîÑ Start attempt \$START_RETRY/\$MAX_START_RETRIES..."
              
              if docker-compose -f docker-compose.yml up -d 2>&1 | tee /tmp/start.log; then
                # Check if there are any port binding errors
                if grep -q "port is already allocated" /tmp/start.log; then
                  echo "‚ö†Ô∏è  Port conflict detected. Cleaning up and retrying..."
                  
                  # Extract port from error message (format: "Bind for 0.0.0.0:8002 failed: port is already allocated")
                  CONFLICT_PORT=\$(grep -oE "Bind for [0-9.]+:([0-9]+)" /tmp/start.log | grep -oE "[0-9]+" | tail -1 || echo "")
                  if [ -z "\$CONFLICT_PORT" ]; then
                    # Try alternative format
                    CONFLICT_PORT=\$(grep "port is already allocated" /tmp/start.log | grep -oE ":[0-9]+" | grep -oE "[0-9]+" | head -1 || echo "")
                  fi
                  if [ -n "\$CONFLICT_PORT" ]; then
                    echo "üîç Freeing port \$CONFLICT_PORT..."
                    kill_port \$CONFLICT_PORT true
                  fi
                  
                  # Cleanup and retry
                  cleanup_docker
                  
                  # Additional aggressive cleanup for the conflicting port
                  if [ -n "\$CONFLICT_PORT" ]; then
                    echo "üîç Performing aggressive cleanup for port \$CONFLICT_PORT..."
                    kill_port \$CONFLICT_PORT true
                  fi
                  sleep 10
                  
                  if [ \$START_RETRY -lt \$MAX_START_RETRIES ]; then
                    continue
                  fi
                else
                  START_SUCCESS=true
                  echo "‚úÖ Services started successfully!"
                fi
              else
                START_EXIT_CODE=\${PIPESTATUS[0]}
                echo "‚ùå Start failed with exit code \$START_EXIT_CODE"
                
                # Check for port conflicts
                if grep -q "port is already allocated" /tmp/start.log; then
                  echo "‚ö†Ô∏è  Port conflict detected. Attempting to resolve..."
                  
                  # Extract all conflicting ports (format: "Bind for 0.0.0.0:8002 failed: port is already allocated")
                  CONFLICT_PORTS=\$(grep -oE "Bind for [0-9.]+:([0-9]+)" /tmp/start.log | grep -oE "[0-9]+" | sort -u || echo "")
                  if [ -n "\$CONFLICT_PORTS" ]; then
                    echo "üîç Freeing conflicting ports..."
                    echo "\$CONFLICT_PORTS" | while read PORT; do
                      if [ -n "\$PORT" ]; then
                        echo "  üîç Freeing port \$PORT..."
                        kill_port \$PORT true
                      fi
                    done
                  fi
                  
                  # Cleanup and retry
                  cleanup_docker
                  
                  # Additional aggressive cleanup for all ports
                  echo "üîç Performing aggressive cleanup for all conflicting ports..."
                  if [ -n "\$CONFLICT_PORTS" ]; then
                    echo "\$CONFLICT_PORTS" | while read PORT; do
                      if [ -n "\$PORT" ]; then
                        kill_port \$PORT true
                      fi
                    done
                  fi
                  sleep 10
                  
                  if [ \$START_RETRY -lt \$MAX_START_RETRIES ]; then
                    continue
                  fi
                fi
                
                if [ \$START_RETRY -eq \$MAX_START_RETRIES ]; then
                  echo "‚ùå Failed to start services after \$MAX_START_RETRIES attempts!"
                  echo "üìã Last 50 lines of start log:"
                  tail -50 /tmp/start.log || true
                  echo ""
                  echo "üìã Container status:"
                  docker-compose -f docker-compose.yml ps || true
                  echo ""
                  echo "üìã Recent logs:"
                  docker-compose -f docker-compose.yml logs --tail=50 || true
                  exit 1
                fi
              fi
            done
            
            if [ "\$START_SUCCESS" = "false" ]; then
              echo "‚ùå Failed to start services after \$MAX_START_RETRIES attempts!"
              exit 1
            fi
            
            # Wait for services to be healthy
            echo "‚è≥ Waiting for services to start (60 seconds)..."
            sleep 60
            
            # Check service status
            echo "üìä Service status:"
            docker-compose -f docker-compose.yml ps
            
            # Show any failed containers
            FAILED_CONTAINERS=\$(docker-compose -f docker-compose.yml ps | grep -E "(Exit|Restarting|unhealthy)" || true)
            if [ -n "\$FAILED_CONTAINERS" ]; then
              echo "‚ö†Ô∏è  Some containers have issues:"
              echo "\$FAILED_CONTAINERS"
              echo ""
              echo "üìã Showing logs for failed containers:"
              docker-compose -f docker-compose.yml logs --tail=100
            fi
            
            # Check SSL certificate
            echo ""
            echo "üîê Checking SSL certificate..."
            SSL_DIR="\$DEPLOY_PATH/infrastructure/nginx/ssl"
            CERT_FILE="\$SSL_DIR/cert.pem"
            KEY_FILE="\$SSL_DIR/key.pem"
            
            if [ ! -f "\$CERT_FILE" ] || [ ! -f "\$KEY_FILE" ]; then
              echo "‚ö†Ô∏è  SSL certificate files not found!"
              echo "   Certificate: \$CERT_FILE"
              echo "   Key: \$KEY_FILE"
              echo ""
              echo "üí° To fix SSL certificate issue:"
              echo "   1. SSH to server: ssh \${{ secrets.SSH_USER_DEV }}@\${{ secrets.SSH_HOST_DEV }}"
              echo "   2. Run: cd \$DEPLOY_PATH && ./scripts/setup-ssl.sh dev your-email@example.com"
              echo "   3. Or check: ./scripts/check-ssl.sh dev"
            else
              echo "‚úÖ SSL certificate files exist"
              
              # Check certificate validity if openssl is available
              if command -v openssl >/dev/null 2>&1; then
                CERT_SUBJECT=\$(openssl x509 -in "\$CERT_FILE" -noout -subject 2>/dev/null | sed 's/subject=//' || echo "")
                CERT_EXPIRY=\$(openssl x509 -in "\$CERT_FILE" -noout -enddate 2>/dev/null | cut -d= -f2 || echo "")
                
                if [ -n "\$CERT_SUBJECT" ]; then
                  echo "   Subject: \$CERT_SUBJECT"
                  if [ -n "\$CERT_EXPIRY" ]; then
                    echo "   Expires: \$CERT_EXPIRY"
                    
                    # Check if certificate matches domain
                    if echo "\$CERT_SUBJECT" | grep -q "devreport.ptkiansantang.com"; then
                      echo "‚úÖ Certificate matches domain"
                    else
                      echo "‚ö†Ô∏è  Certificate does NOT match domain devreport.ptkiansantang.com"
                      echo "   Run: ./scripts/setup-ssl.sh dev your-email@example.com"
                    fi
                  fi
                fi
              fi
            fi
          EOF

      - name: Verify deployment
        env:
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH_DEV || '/opt/ksm-main-dev' }}
        run: |
          ssh -p 22 ${{ secrets.SSH_USER_DEV }}@${{ secrets.SSH_HOST_DEV }} << EOF
            cd $DEPLOY_PATH
            
            # Get container status
            CONTAINER_STATUS=\$(docker-compose -f docker-compose.yml ps)
            echo "üìä Current container status:"
            echo "\$CONTAINER_STATUS"
            echo ""
            
            # Count running containers
            RUNNING_COUNT=\$(echo "\$CONTAINER_STATUS" | grep -c "Up" || echo "0")
            TOTAL_COUNT=\$(echo "\$CONTAINER_STATUS" | grep -v "NAME" | grep -v "^--" | wc -l || echo "0")
            
            echo "Running containers: \$RUNNING_COUNT / \$TOTAL_COUNT"
            echo ""
            
            # Check if containers are running
            if [ "\$RUNNING_COUNT" -gt 0 ]; then
              echo "‚úÖ Deployment successful! \$RUNNING_COUNT service(s) are running."
              echo ""
              echo "üìã Service details:"
              docker-compose -f docker-compose.yml ps
              
              # Show any non-running containers
              NON_RUNNING=\$(echo "\$CONTAINER_STATUS" | grep -v "Up" | grep -v "NAME" | grep -v "^--" || true)
              if [ -n "\$NON_RUNNING" ]; then
                echo ""
                echo "‚ö†Ô∏è  Some services are not running:"
                echo "\$NON_RUNNING"
                echo ""
                echo "üìã Logs for non-running services:"
                docker-compose -f docker-compose.yml logs --tail=50
              fi
            else
              echo "‚ùå Deployment failed! No services are running."
              echo ""
              echo "üìã All container status:"
              docker-compose -f docker-compose.yml ps
              echo ""
              echo "üìã Recent logs:"
              docker-compose -f docker-compose.yml logs --tail=100
              echo ""
              echo "üîç Checking for common issues:"
              echo "  - .env file: \$([ -f .env ] && echo '‚úÖ exists' || echo '‚ùå missing')"
              echo "  - Docker compose file: \$([ -f docker-compose.yml ] && echo '‚úÖ exists' || echo '‚ùå missing')"
              echo "  - Disk space:"
              df -h | head -2
              exit 1
            fi
          EOF

      - name: Cleanup old images
        if: success()
        run: |
          ssh -p 22 ${{ secrets.SSH_USER_DEV }}@${{ secrets.SSH_HOST_DEV }} << EOF
            # Remove dangling images
            docker image prune -f
            
            # Remove unused images (older than 7 days)
            docker image prune -a -f --filter "until=168h" || true
          EOF

